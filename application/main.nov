// Manifold Edge Remover
//
// Modes:
//   CLI:  ./manifold-edge-remover --file ./model.stl
//   GUI:  ./manifold-edge-remover   (opens a WebKit window)
//
// All STL processing done natively in Novus.
// Mac Silicon only.

module manifold_edge_remover;

import ../lib/standard_lib_macos_silicon;
import ../lib/mac_silicon_window_manager;
import ../lib/memory;
import ../lib/file_io;
import ../lib/process;

// =========================================================================
// Utility helpers (app-specific)
// =========================================================================

fn make_out_path(path: str) -> str {
    return path_insert_suffix(path, "_FIXED");
}

fn send_prog(fd: i32, pct: i32, msg: str) -> void {
    if (fd >= 0) {
        wm_send_to_js(fd, "PROGRESS:" + int_to_str(pct) + ":" + msg);
    }
    print("[" + int_to_str(pct) + "%] " + msg);
}

// =========================================================================
// Vertex hash table (interleaved coords: [vx,vy,vz,...])
// All functions ≤ 8 params
// =========================================================================

fn vert_hash(nvx: i32, nvy: i32, nvz: i32, ts: i32) -> i32 {
    let h: i32 = nvx * 7919 + nvy * 7877 + nvz * 7867;
    if (h < 0) { h = 0 - h; }
    return h % ts;
}

fn vert_find_or_insert(
    coords: []i32, heads: []i32,
    next: []i32, num_v: []i32,
    nvx: i32, nvy: i32,
    nvz: i32, ts: i32
) -> i32 {
    let bucket: i32 = vert_hash(nvx, nvy, nvz, ts);
    let cur: i32 = heads[bucket];
    while (cur != -1) {
        let ci: i32 = cur * 3;
        if (coords[ci] == nvx && coords[ci + 1] == nvy && coords[ci + 2] == nvz) {
            return cur;
        }
        cur = next[cur];
    }
    let id: i32 = num_v[0];
    num_v[0] = id + 1;
    array_append(coords, nvx);
    array_append(coords, nvy);
    array_append(coords, nvz);
    array_append(next, heads[bucket]);
    heads[bucket] = id;
    return id;
}

// =========================================================================
// Edge hash table (interleaved edata: [a,b,count,...])
// =========================================================================

fn edge_hash(va: i32, vb: i32, ts: i32) -> i32 {
    let a: i32 = va;
    let b: i32 = vb;
    if (a > b) { let t: i32 = a; a = b; b = t; }
    let h: i32 = (a * 7919 + b * 7877) % ts;
    if (h < 0) { h = 0 - h; }
    return h;
}

fn edge_find_or_inc(
    edata: []i32, eheads: []i32,
    enext: []i32, num_e: []i32,
    va: i32, vb: i32, ts: i32
) -> void {
    let a: i32 = va;
    let b: i32 = vb;
    if (a > b) { let t: i32 = a; a = b; b = t; }
    let h: i32 = edge_hash(va, vb, ts);
    let cur: i32 = eheads[h];
    while (cur != -1) {
        let ci: i32 = cur * 3;
        if (edata[ci] == a && edata[ci + 1] == b) {
            edata[ci + 2] = edata[ci + 2] + 1;
            return;
        }
        cur = enext[cur];
    }
    let eid: i32 = num_e[0];
    num_e[0] = eid + 1;
    array_append(edata, a);
    array_append(edata, b);
    array_append(edata, 1);
    array_append(enext, eheads[h]);
    eheads[h] = eid;
}

fn edge_get_count(
    edata: []i32, eheads: []i32,
    enext: []i32, va: i32,
    vb: i32, ts: i32
) -> i32 {
    let a: i32 = va;
    let b: i32 = vb;
    if (a > b) { let t: i32 = a; a = b; b = t; }
    let h: i32 = edge_hash(va, vb, ts);
    let cur: i32 = eheads[h];
    while (cur != -1) {
        let ci: i32 = cur * 3;
        if (edata[ci] == a && edata[ci + 1] == b) {
            return edata[ci + 2];
        }
        cur = enext[cur];
    }
    return 0;
}

fn edge_set_count(
    edata: []i32, eheads: []i32,
    enext: []i32, va: i32,
    vb: i32, ts: i32, nc: i32
) -> void {
    let a: i32 = va;
    let b: i32 = vb;
    if (a > b) { let t: i32 = a; a = b; b = t; }
    let h: i32 = edge_hash(va, vb, ts);
    let cur: i32 = eheads[h];
    while (cur != -1) {
        let ci: i32 = cur * 3;
        if (edata[ci] == a && edata[ci + 1] == b) {
            edata[ci + 2] = nc;
            return;
        }
        cur = enext[cur];
    }
}

// =========================================================================
// Duplicate face detection (fkeys interleaved [a,b,c,...])
// =========================================================================

fn face_is_dup(
    fkeys: []i32, fheads: []i32,
    fnext: []i32, num_u: []i32,
    v0: i32, v1: i32,
    v2: i32, ts: i32
) -> bool {
    let a: i32 = v0;
    let b: i32 = v1;
    let c: i32 = v2;
    if (a > b) { let t: i32 = a; a = b; b = t; }
    if (b > c) { let t: i32 = b; b = c; c = t; }
    if (a > b) { let t: i32 = a; a = b; b = t; }
    let h: i32 = a * 7919 + b * 7877 + c * 7867;
    if (h < 0) { h = 0 - h; }
    h = h % ts;
    let cur: i32 = fheads[h];
    while (cur != -1) {
        let ci: i32 = cur * 3;
        if (fkeys[ci] == a && fkeys[ci + 1] == b && fkeys[ci + 2] == c) {
            return true;
        }
        cur = fnext[cur];
    }
    let fid: i32 = num_u[0];
    num_u[0] = fid + 1;
    array_append(fkeys, a);
    array_append(fkeys, b);
    array_append(fkeys, c);
    array_append(fnext, fheads[h]);
    fheads[h] = fid;
    return false;
}

// =========================================================================
// Hash table init
// =========================================================================

fn init_ht(heads: []i32, size: i32) -> void {
    let i: i32 = 0;
    while (i < size) {
        array_append(heads, -1);
        i = i + 1;
    }
}

// =========================================================================
// Phase 1: Parse + vertex dedup
// results = interleaved [id0, id1, id2, orig_idx, ...]
// =========================================================================

fn do_parse(
    base: u64, tri_count: i32,
    coords: []i32, heads: []i32,
    next: []i32, num_v: []i32,
    ts: i32, results: []i32
) -> void {
    let off: u64 = 84;
    let i: i32 = 0;
    let rpt: i32 = tri_count / 20;
    if (rpt < 1) { rpt = 1; }

    while (i < tri_count) {
        if (i % rpt == 0) {
            print("  Parse: " + int_to_str(i * 100 / tri_count) + "%");
        }
        let v0x: i32 = load32(base + off + 12);
        let v0y: i32 = load32(base + off + 16);
        let v0z: i32 = load32(base + off + 20);
        let v1x: i32 = load32(base + off + 24);
        let v1y: i32 = load32(base + off + 28);
        let v1z: i32 = load32(base + off + 32);
        let v2x: i32 = load32(base + off + 36);
        let v2y: i32 = load32(base + off + 40);
        let v2z: i32 = load32(base + off + 44);

        let id0: i32 = vert_find_or_insert(coords, heads, next, num_v, v0x, v0y, v0z, ts);
        let id1: i32 = vert_find_or_insert(coords, heads, next, num_v, v1x, v1y, v1z, ts);
        let id2: i32 = vert_find_or_insert(coords, heads, next, num_v, v2x, v2y, v2z, ts);

        array_append(results, id0);
        array_append(results, id1);
        array_append(results, id2);
        array_append(results, i);

        off = off + 50;
        i = i + 1;
    }
}

// =========================================================================
// Phase 2: Filter degenerates + duplicates
// faces = interleaved [v0, v1, v2, orig_idx, ...]
// After: results[0]=num_faces, [1]=degenerate, [2]=duplicate
// =========================================================================

fn do_filter(
    results: []i32, tri_count: i32,
    fkeys: []i32, fheads: []i32,
    fnext: []i32, num_u: []i32,
    fts: i32, faces: []i32
) -> void {
    let idx: i32 = 0;
    let i: i32 = 0;
    let nf: i32 = 0;
    let deg: i32 = 0;
    let dup: i32 = 0;

    while (i < tri_count) {
        let id0: i32 = results[idx];
        let id1: i32 = results[idx + 1];
        let id2: i32 = results[idx + 2];
        let orig: i32 = results[idx + 3];

        if (id0 == id1 || id1 == id2 || id0 == id2) {
            deg = deg + 1;
        } else if (face_is_dup(fkeys, fheads, fnext, num_u, id0, id1, id2, fts)) {
            dup = dup + 1;
        } else {
            array_append(faces, id0);
            array_append(faces, id1);
            array_append(faces, id2);
            array_append(faces, orig);
            nf = nf + 1;
        }

        idx = idx + 4;
        i = i + 1;
    }

    results[0] = nf;
    results[1] = deg;
    results[2] = dup;
}

// =========================================================================
// Phase 3: Edge analysis
// =========================================================================

fn do_edges(
    faces: []i32, num_faces: i32,
    edata: []i32, eheads: []i32,
    enext: []i32, num_e: []i32,
    ets: i32, stats: []i32
) -> void {
    let fi: i32 = 0;
    while (fi < num_faces) {
        let bi: i32 = fi * 4;
        let v0: i32 = faces[bi];
        let v1: i32 = faces[bi + 1];
        let v2: i32 = faces[bi + 2];
        edge_find_or_inc(edata, eheads, enext, num_e, v0, v1, ets);
        edge_find_or_inc(edata, eheads, enext, num_e, v1, v2, ets);
        edge_find_or_inc(edata, eheads, enext, num_e, v2, v0, ets);
        fi = fi + 1;
    }

    let total: i32 = num_e[0];
    let bnd: i32 = 0;
    let nm: i32 = 0;
    let ej: i32 = 0;
    while (ej < total) {
        let c: i32 = edata[ej * 3 + 2];
        if (c == 1) { bnd = bnd + 1; }
        else if (c > 2) { nm = nm + 1; }
        ej = ej + 1;
    }

    stats[0] = total;
    stats[1] = bnd;
    stats[2] = nm;
}

// =========================================================================
// Phase 4: Non-manifold fix
// =========================================================================

fn chk_face_e(
    faces: []i32, fi: i32,
    edata: []i32, eheads: []i32,
    enext: []i32, ets: i32
) -> bool {
    let bi: i32 = fi * 4;
    let v0: i32 = faces[bi];
    let v1: i32 = faces[bi + 1];
    let v2: i32 = faces[bi + 2];
    let c0: i32 = edge_get_count(edata, eheads, enext, v0, v1, ets);
    if (c0 >= 2) { return false; }
    let c1: i32 = edge_get_count(edata, eheads, enext, v1, v2, ets);
    if (c1 >= 2) { return false; }
    let c2: i32 = edge_get_count(edata, eheads, enext, v2, v0, ets);
    if (c2 >= 2) { return false; }
    return true;
}

fn inc_face_e(
    faces: []i32, fi: i32,
    edata: []i32, eheads: []i32,
    enext: []i32, ets: i32
) -> void {
    let bi: i32 = fi * 4;
    let v0: i32 = faces[bi];
    let v1: i32 = faces[bi + 1];
    let v2: i32 = faces[bi + 2];
    let c0: i32 = edge_get_count(edata, eheads, enext, v0, v1, ets);
    edge_set_count(edata, eheads, enext, v0, v1, ets, c0 + 1);
    let c1: i32 = edge_get_count(edata, eheads, enext, v1, v2, ets);
    edge_set_count(edata, eheads, enext, v1, v2, ets, c1 + 1);
    let c2: i32 = edge_get_count(edata, eheads, enext, v2, v0, ets);
    edge_set_count(edata, eheads, enext, v2, v0, ets, c2 + 1);
}

fn do_fix_nm(
    faces: []i32, keep: []i32,
    nf: i32, edata: []i32,
    eheads: []i32, enext: []i32,
    tot_e: i32, ets: i32
) -> i32 {
    let ek: i32 = 0;
    while (ek < tot_e) {
        edata[ek * 3 + 2] = 0;
        ek = ek + 1;
    }

    let fi: i32 = 0;
    let rm: i32 = 0;
    while (fi < nf) {
        let ok: bool = chk_face_e(faces, fi, edata, eheads, enext, ets);
        if (ok) {
            keep[fi] = 1;
            inc_face_e(faces, fi, edata, eheads, enext, ets);
        } else {
            keep[fi] = 0;
            rm = rm + 1;
        }
        fi = fi + 1;
    }
    return rm;
}

// =========================================================================
// Boundary loop capping (closes holes left by removed faces)
// =========================================================================

// Find an unused boundary edge touching vertex v.
fn find_bnd_edge(
    bnd_a: []i32, bnd_b: []i32,
    bnd_used: []i32, num_bnd: i32,
    v: i32
) -> i32 {
    let i: i32 = 0;
    while (i < num_bnd) {
        if (bnd_used[i] == 0) {
            if (bnd_a[i] == v || bnd_b[i] == v) { return i; }
        }
        i = i + 1;
    }
    return -1;
}

// Collect boundary edges (count==1), trace loops, fan-triangulate.
// Appends cap triangle vertex IDs to cap_ids [v0,v1,v2,...].
// Returns number of cap triangles created.
fn do_cap_boundaries(
    edata: []i32, num_e: i32,
    cap_ids: []i32
) -> i32 {
    // Collect boundary edges
    let bnd_a: []i32 = [];
    let bnd_b: []i32 = [];
    let bnd_used: []i32 = [];
    let ej: i32 = 0;
    while (ej < num_e) {
        if (edata[ej * 3 + 2] == 1) {
            array_append(bnd_a, edata[ej * 3]);
            array_append(bnd_b, edata[ej * 3 + 1]);
            array_append(bnd_used, 0);
        }
        ej = ej + 1;
    }
    let num_bnd: i32 = array_len(bnd_a);
    if (num_bnd == 0) { return 0; }

    let num_caps: i32 = 0;

    // Trace and cap loops
    let done: bool = false;
    while (!done) {
        // Find first unused boundary edge
        let start: i32 = -1;
        let si: i32 = 0;
        while (si < num_bnd) {
            if (bnd_used[si] == 0) { start = si; si = num_bnd; }
            si = si + 1;
        }
        if (start == -1) {
            done = true;
        } else {
            // Trace a loop
            let loop_v: []i32 = [];
            let first_v: i32 = bnd_a[start];
            let next_v: i32 = bnd_b[start];
            bnd_used[start] = 1;
            array_append(loop_v, first_v);

            let loop_ok: bool = false;
            let iter: i32 = 0;
            while (iter <= num_bnd) {
                if (next_v == first_v) {
                    loop_ok = true;
                    iter = num_bnd + 1;
                } else {
                    array_append(loop_v, next_v);
                    let eidx: i32 = find_bnd_edge(bnd_a, bnd_b, bnd_used, num_bnd, next_v);
                    if (eidx == -1) {
                        iter = num_bnd + 1;
                    } else {
                        bnd_used[eidx] = 1;
                        if (bnd_a[eidx] == next_v) {
                            next_v = bnd_b[eidx];
                        } else {
                            next_v = bnd_a[eidx];
                        }
                        iter = iter + 1;
                    }
                }
            }

            let nloop: i32 = array_len(loop_v);
            if (loop_ok && nloop >= 3) {
                // Fan triangulate: hub = loop_v[0]
                let hub: i32 = loop_v[0];
                let ti: i32 = 1;
                while (ti < nloop - 1) {
                    array_append(cap_ids, hub);
                    array_append(cap_ids, loop_v[ti]);
                    array_append(cap_ids, loop_v[ti + 1]);
                    num_caps = num_caps + 1;
                    ti = ti + 1;
                }
            }
        }
    }

    return num_caps;
}

// =========================================================================
// Write output STL
// =========================================================================

// Write 4 raw bytes of an i32 to a file descriptor.
fn write_i32_raw(fd: i32, val: i32) -> void {
    let v: i32 = val;
    let a: u64 = &v;
    mov(x0, fd);
    mov(x1, a);
    mov(x2, 4);
    mov(x16, 0x2000004);
    syscall();
}

// Write a vertex's 3 float32 components from the coords array.
fn write_cap_vert(fd: i32, coords: []i32, vid: i32) -> void {
    let ci: i32 = vid * 3;
    write_i32_raw(fd, coords[ci]);
    write_i32_raw(fd, coords[ci + 1]);
    write_i32_raw(fd, coords[ci + 2]);
}

fn write_stl(
    base: u64, path: str,
    keep: []i32, faces: []i32,
    nf: i32, kept: i32,
    cap_ids: []i32, num_caps: i32,
    coords: []i32
) -> void {
    mov(x0, path);
    mov(x1, 1537);
    mov(x2, 420);
    mov(x16, 0x2000005);
    syscall();
    let ofd: i32 = u64_to_i32(getreg(x0));
    if (ofd < 0) {
        print("ERROR: Failed to create output file");
        return;
    }

    // Write 80-byte header
    mov(x0, ofd);
    mov(x1, base);
    mov(x2, 80);
    mov(x16, 0x2000004);
    syscall();

    // Write triangle count (kept + caps)
    let cnt: i32 = kept + num_caps;
    let ca: u64 = &cnt;
    mov(x0, ofd);
    mov(x1, ca);
    mov(x2, 4);
    mov(x16, 0x2000004);
    syscall();

    // Write kept triangles (copy 50 bytes each from mmap'd source)
    let fj: i32 = 0;
    while (fj < nf) {
        if (keep[fj] == 1) {
            let oi: u64 = i32_to_u64(faces[fj * 4 + 3]);
            let to: u64 = 84 + oi * 50;
            mov(x0, ofd);
            mov(x1, base + to);
            mov(x2, 50);
            mov(x16, 0x2000004);
            syscall();
        }
        fj = fj + 1;
    }

    // Write cap triangles (new faces to close boundary loops)
    let ci: i32 = 0;
    while (ci < num_caps) {
        let bi: i32 = ci * 3;
        // Normal: all zeros (slicer recalculates)
        write_i32_raw(ofd, 0);
        write_i32_raw(ofd, 0);
        write_i32_raw(ofd, 0);
        // Vertices
        write_cap_vert(ofd, coords, cap_ids[bi]);
        write_cap_vert(ofd, coords, cap_ids[bi + 1]);
        write_cap_vert(ofd, coords, cap_ids[bi + 2]);
        // Attribute byte count (2 bytes of zero)
        let attr: i32 = 0;
        let aa: u64 = &attr;
        mov(x0, ofd);
        mov(x1, aa);
        mov(x2, 2);
        mov(x16, 0x2000004);
        syscall();
        ci = ci + 1;
    }

    mov(x0, ofd);
    mov(x16, 0x2000006);
    syscall();
}

// =========================================================================
// Process an STL file. gui_fd=-1 for CLI mode.
// Returns result info via res array: [kept, total_removed, unique_verts, boundary, nonmanifold]
// =========================================================================

fn process_stl(path: str, gui_fd: i32, res: []i32) -> void {
    send_prog(gui_fd, 5, "Opening file...");

    // Open
    mov(x0, path);
    mov(x1, 0);
    mov(x2, 0);
    mov(x16, 0x2000005);
    syscall();
    let fd: i32 = u64_to_i32(getreg(x0));
    if (fd < 0) {
        print("ERROR: Cannot open " + path);
        if (gui_fd >= 0) {
            wm_send_to_js(gui_fd, "ERROR:Cannot open file");
        }
        return;
    }

    // File size
    mov(x0, fd);
    mov(x1, 0);
    mov(x2, 2);
    mov(x16, 0x20000C7);
    syscall();
    let fsz: u64 = getreg(x0);

    // mmap
    mov(x0, 0);
    mov(x1, fsz);
    mov(x2, 1);
    mov(x3, 2);
    mov(x4, fd);
    mov(x5, 0);
    mov(x16, 0x20000C5);
    syscall();
    let base: u64 = getreg(x0);

    let tc: i32 = load32(base + 80);
    send_prog(gui_fd, 10, "Triangles: " + int_to_str(tc));

    // Phase 1: Vertex dedup
    let vts: i32 = tc * 2;
    if (vts < 1024) { vts = 1024; }
    let coords: []i32 = [];
    let vheads: []i32 = [];
    let vnext: []i32 = [];
    let nv: []i32 = [0];
    send_prog(gui_fd, 15, "Initializing...");
    init_ht(vheads, vts);

    let results: []i32 = [];
    send_prog(gui_fd, 20, "Parsing vertices...");
    do_parse(base, tc, coords, vheads, vnext, nv, vts, results);
    send_prog(gui_fd, 45, "Vertices: " + int_to_str(nv[0]));

    // Phase 2: Filter
    let fts: i32 = tc;
    if (fts < 1024) { fts = 1024; }
    let fkeys: []i32 = [];
    let fheads: []i32 = [];
    let fnext: []i32 = [];
    let nu: []i32 = [0];
    init_ht(fheads, fts);

    let faces: []i32 = [];
    send_prog(gui_fd, 50, "Filtering faces...");
    do_filter(results, tc, fkeys, fheads, fnext, nu, fts, faces);

    let nf: i32 = results[0];
    let deg: i32 = results[1];
    let dup: i32 = results[2];
    send_prog(gui_fd, 60, "Faces: " + int_to_str(nf) + " (removed " + int_to_str(deg + dup) + ")");

    // Phase 3: Edges
    let ets: i32 = nf * 2;
    if (ets < 1024) { ets = 1024; }
    let edata: []i32 = [];
    let eheads: []i32 = [];
    let enext: []i32 = [];
    let ne: []i32 = [0];
    init_ht(eheads, ets);

    let es: []i32 = [0, 0, 0];
    send_prog(gui_fd, 65, "Analyzing edges...");
    do_edges(faces, nf, edata, eheads, enext, ne, ets, es);

    let tot_e: i32 = es[0];
    let bnd: i32 = es[1];
    let nm: i32 = es[2];
    send_prog(gui_fd, 75, "Edges: " + int_to_str(tot_e) + " boundary=" + int_to_str(bnd) + " nm=" + int_to_str(nm));

    // Phase 4: Fix non-manifold
    let keep: []i32 = [];
    let fk: i32 = 0;
    while (fk < nf) {
        array_append(keep, 1);
        fk = fk + 1;
    }

    let nm_rm: i32 = 0;
    if (nm > 0) {
        send_prog(gui_fd, 80, "Fixing non-manifold edges...");
        nm_rm = do_fix_nm(faces, keep, nf, edata, eheads, enext, tot_e, ets);
        send_prog(gui_fd, 82, "Removed " + int_to_str(nm_rm) + " non-manifold faces");
    }

    // Phase 5: Cap boundary loops (close holes)
    let cap_ids: []i32 = [];
    let num_caps: i32 = do_cap_boundaries(edata, ne[0], cap_ids);
    if (num_caps > 0) {
        send_prog(gui_fd, 85, "Capped boundaries: +" + int_to_str(num_caps) + " faces");
        // Add cap edges to edge table for final stats
        let ci: i32 = 0;
        while (ci < num_caps) {
            let bi: i32 = ci * 3;
            edge_find_or_inc(edata, eheads, enext, ne, cap_ids[bi], cap_ids[bi + 1], ets);
            edge_find_or_inc(edata, eheads, enext, ne, cap_ids[bi + 1], cap_ids[bi + 2], ets);
            edge_find_or_inc(edata, eheads, enext, ne, cap_ids[bi + 2], cap_ids[bi], ets);
            ci = ci + 1;
        }
    }

    // Final edge stats
    let fin_e: i32 = ne[0];
    let fin_bnd: i32 = 0;
    let fin_nm: i32 = 0;
    let ek2: i32 = 0;
    while (ek2 < fin_e) {
        let c: i32 = edata[ek2 * 3 + 2];
        if (c == 1) { fin_bnd = fin_bnd + 1; }
        else if (c > 2) { fin_nm = fin_nm + 1; }
        ek2 = ek2 + 1;
    }

    // Count kept
    let kept: i32 = 0;
    let fj: i32 = 0;
    while (fj < nf) {
        if (keep[fj] == 1) { kept = kept + 1; }
        fj = fj + 1;
    }

    let total_out: i32 = kept + num_caps;

    // Write output
    let out: str = make_out_path(path);
    send_prog(gui_fd, 90, "Writing " + int_to_str(total_out) + " faces...");
    write_stl(base, out, keep, faces, nf, kept, cap_ids, num_caps, coords);
    send_prog(gui_fd, 100, "Done! Saved to " + out);

    // Store results
    res[0] = total_out;
    res[1] = deg + dup + nm_rm;
    res[2] = nv[0];
    res[3] = fin_bnd;
    res[4] = fin_nm;
    res[5] = tc;

    // Close file
    mov(x0, fd);
    mov(x16, 0x2000006);
    syscall();

    // Send result to GUI
    if (gui_fd >= 0) {
        let status: str = "OK";
        if (fin_bnd > 0 || fin_nm > 0) { status = "PARTIAL"; }
        wm_send_to_js(gui_fd, "RESULT:" + status + ":" + out + ":" + int_to_str(nv[0]) + ":" + int_to_str(tc) + ":" + int_to_str(nv[0]) + ":" + int_to_str(total_out));
    }
}

// =========================================================================
// File picker via osascript
// =========================================================================

fn pick_file() -> str {
    return pick_file_dialog("stl");
}

// =========================================================================
// GUI event loop
// =========================================================================

fn gui_loop(fd: i32) -> void {
    let running: bool = true;
    while (running) {
        let msg: str = wm_recv_js_msg(fd);
        if (len(msg) == 0) {
            running = false;
        } else if (msg == "READY") {
            // Web page loaded
            print("GUI ready");
        } else if (msg == "CMD:SELECT_FILE") {
            let path: str = pick_file();
            if (len(path) > 0) {
                wm_send_to_js(fd, "FILE_SELECTED:" + path);
                print("Selected: " + path);
            } else {
                print("File selection cancelled");
            }
        } else if (starts_with(msg, "CMD:PROCESS:")) {
            let path: str = substr(msg, 12);
            print("Processing: " + path);
            let res: []i32 = [0, 0, 0, 0, 0, 0];
            process_stl(path, fd, res);
        } else if (msg == "CMD:QUIT") {
            print("Quit requested");
            running = false;
        } else {
            print("Unknown msg: " + msg);
        }
    }

    wm_quit(fd);
}

// =========================================================================
// chdir helper
// =========================================================================

fn chdir(path: str) -> i32 {
    mov(x0, path);
    mov(x16, 0x200000C);  // SYS_chdir = 12
    syscall();
    return u64_to_i32(getreg(x0));
}

// =========================================================================
// Standalone binary support
//
// When built with build.sh, the executable has embedded resources appended:
//   [original binary][window_manager][index.html][app.js][style.css][footer]
// Footer = 4×uint32 LE sizes + "NVWM" magic (20 bytes total).
//
// At runtime we detect the magic, extract files to /tmp/novus_mer/,
// and use those paths instead of the project directory.
// =========================================================================

fn write_mem_to_file(src: u64, size: i32, path: str) -> void {
    let fd: i32 = file_open_write(path);
    if (fd < 0) { return; }
    let written: i32 = 0;
    while (written < size) {
        let chunk: i32 = size - written;
        if (chunk > 32768) { chunk = 32768; }
        let addr: u64 = src + i32_to_u64(written);
        let n: i32 = file_write(fd, addr, chunk);
        if (n <= 0) { break; }
        written = written + n;
    }
    file_close(fd);
}

fn check_embed_magic(base: u64, fsize: u64) -> bool {
    let moff: u64 = fsize - 4;
    let m0: i32 = read_byte(base + moff);
    let m1: i32 = read_byte(base + moff + 1);
    let m2: i32 = read_byte(base + moff + 2);
    let m3: i32 = read_byte(base + moff + 3);
    // N=78 V=86 W=87 M=77
    if (m0 != 78) { return false; }
    if (m1 != 86) { return false; }
    if (m2 != 87) { return false; }
    if (m3 != 77) { return false; }
    return true;
}

fn extract_web(base: u64, doff: u64, sizes: []i32, tmp_web: str) -> void {
    let wm_sz: i32 = sizes[0];
    let html_sz: i32 = sizes[1];
    let js_sz: i32 = sizes[2];
    let css_sz: i32 = sizes[3];

    let off: u64 = doff + i32_to_u64(wm_sz);
    write_mem_to_file(base + off, html_sz, tmp_web + "/index.html");

    off = off + i32_to_u64(html_sz);
    write_mem_to_file(base + off, js_sz, tmp_web + "/app.js");

    off = off + i32_to_u64(js_sz);
    write_mem_to_file(base + off, css_sz, tmp_web + "/style.css");
}

fn extract_embedded(exe_path: str) -> str {
    let fd: i32 = file_open_read(exe_path);
    if (fd < 0) { return ""; }

    let fsize: u64 = file_size(fd);
    let base: u64 = file_mmap_read(fd, fsize);

    if (!check_embed_magic(base, fsize)) {
        file_munmap(base, fsize);
        file_close(fd);
        return "";
    }

    // Read 4 sizes from footer (LE uint32 at fsize - 20)
    let soff: u64 = fsize - 20;
    let sizes: []i32 = [
        load32(base + soff),
        load32(base + soff + 4),
        load32(base + soff + 8),
        load32(base + soff + 12)
    ];

    let total: i32 = sizes[0] + sizes[1] + sizes[2] + sizes[3];
    let doff: u64 = fsize - 20 - i32_to_u64(total);

    let tmp: str = "/tmp/novus_mer";
    sys_mkdir(tmp, 493);
    sys_mkdir(tmp + "/web", 493);

    // Extract window_manager
    write_mem_to_file(base + doff, sizes[0], tmp + "/wm");
    sys_chmod(tmp + "/wm", 493);

    // Extract web files
    extract_web(base, doff, sizes, tmp + "/web");

    file_munmap(base, fsize);
    file_close(fd);

    return tmp;
}

// =========================================================================
// Main
// =========================================================================

fn main() -> i32 {
    // Save argc/argv before any function calls
    let raw0: u64 = getreg(x0);
    let raw1: u64 = getreg(x1);
    let argc: i32 = u64_to_i32(raw0);
    let argv: u64 = raw1;

    // Get executable path from argv[0]
    let exe_path: str = cstr_to_str(i64_to_u64(load64(argv)));

    // Try to extract embedded resources (standalone mode)
    let embed_dir: str = extract_embedded(exe_path);

    if (len(embed_dir) == 0) {
        // Dev mode: chdir to project root so relative paths work
        let exe_dir: str = path_dir(exe_path);
        if (len(exe_dir) > 0) {
            let proot: str = path_dir(path_dir(exe_dir));
            if (len(proot) > 0) {
                chdir(proot);
            }
        }
    }

    // Check for --file argument
    if (argc >= 3) {
        let a1: str = cstr_to_str(i64_to_u64(load64(argv + 8)));
        if (a1 == "--file") {
            let a2: str = cstr_to_str(i64_to_u64(load64(argv + 16)));
            print("=== Manifold Edge Remover (CLI) ===");
            print("File: " + a2);
            let res: []i32 = [0, 0, 0, 0, 0, 0];
            process_stl(a2, -1, res);
            let kept: i32 = res[0];
            let removed: i32 = res[1];
            let verts: i32 = res[2];
            let bnd: i32 = res[3];
            let nm_edges: i32 = res[4];
            let orig_tc: i32 = res[5];
            print("");
            print("=== Summary ===");
            print("Input:  " + int_to_str(orig_tc) + " triangles");
            print("Output: " + int_to_str(kept) + " triangles");
            if (removed > 0) {
                print("Removed: " + int_to_str(removed) + " faces");
            }
            print("Unique vertices: " + int_to_str(verts));
            if (bnd == 0 && nm_edges == 0) {
                print("Mesh is watertight and ready for 3D printing!");
            } else {
                if (bnd > 0) {
                    print("Remaining boundary edges: " + int_to_str(bnd));
                }
                if (nm_edges > 0) {
                    print("Remaining non-manifold edges: " + int_to_str(nm_edges));
                }
            }
            exit(0);
            return 0;
        }
    }

    // GUI mode
    print("=== Manifold Edge Remover (GUI) ===");
    let wm_exe: str = "";
    let web_dir: str = "application/web";
    if (len(embed_dir) > 0) {
        wm_exe = embed_dir + "/wm";
        web_dir = embed_dir + "/web";
    }
    let fd: i32 = wm_open("Manifold Edge Remover", wm_exe);
    let resp: str = wm_serve(fd, web_dir);
    let port: i32 = wm_parse_port(resp);
    if (port < 0) {
        print("ERROR: Failed to start HTTP server");
        wm_quit(fd);
        wm_close(fd);
        exit(1);
        return 1;
    }
    let url: str = "http://127.0.0.1:" + int_to_str(port) + "/";
    wm_navigate(fd, url);
    wm_show(fd);
    print("Window opened on " + url);

    gui_loop(fd);

    wm_close(fd);
    print("Goodbye.");
    exit(0);
    return 0;
}
